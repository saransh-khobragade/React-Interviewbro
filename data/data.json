{
  "questions": [
    {
      "id": "1",
      "title": "1. Two Sum (Hashmap pattern)",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "array",
        "hash-table"
      ],
      "solution": "Use a hash map to store each number and its index. For each number, check if target - number exists in the map.",
      "examples": [
        "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]",
        "Input: nums = [3,2,4], target = 6\nOutput: [1,2]"
      ],
      "codeSnippet": "function twoSum(nums: number[], target: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement)!, i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z"
    },
    {
      "id": "2",
      "title": "2. Best Time to Buy and Sell Stock (Greedy pattern)",
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "array",
        "greedy"
      ],
      "solution": "Track the minimum price seen so far and calculate the maximum profit at each step.",
      "examples": [
        "Input: prices = [7,1,5,3,6,4]\nOutput: 5"
      ],
      "codeSnippet": "function maxProfit(prices: number[]): number {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (let price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  return maxProfit;\n}",
      "createdAt": "2024-01-02T00:00:00.000Z",
      "updatedAt": "2024-01-02T00:00:00.000Z"
    },
    {
      "id": "3",
      "title": "3. Contains Duplicate (Hashmap pattern)",
      "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "array",
        "hash-table"
      ],
      "solution": "Use a hash set to track seen numbers. If a number is already in the set, return true.",
      "examples": [
        "Input: nums = [1,2,3,1]\nOutput: true"
      ],
      "codeSnippet": "function containsDuplicate(nums: number[]): boolean {\n  const set = new Set<number>();\n  for (let num of nums) {\n    if (set.has(num)) return true;\n    set.add(num);\n  }\n  return false;\n}",
      "createdAt": "2024-01-03T00:00:00.000Z",
      "updatedAt": "2024-01-03T00:00:00.000Z"
    },
    {
      "id": "4",
      "title": "4. Product of Array Except Self (Prefix Sum pattern)",
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "prefix-sum"
      ],
      "solution": "Use prefix and suffix products. Calculate left products first, then right products in reverse.",
      "examples": [
        "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]"
      ],
      "codeSnippet": "function productExceptSelf(nums: number[]): number[] {\n  const result = new Array(nums.length).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < nums.length; i++) {\n    result[i] = prefix;\n    prefix *= nums[i];\n  }\n  let suffix = 1;\n  for (let i = nums.length - 1; i >= 0; i--) {\n    result[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return result;\n}",
      "createdAt": "2024-01-04T00:00:00.000Z",
      "updatedAt": "2024-01-04T00:00:00.000Z"
    },
    {
      "id": "5",
      "title": "5. Maximum Subarray (Kadane's Algorithm pattern)",
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dynamic-programming"
      ],
      "solution": "Use Kadanes algorithm. Track the maximum sum ending at each position.",
      "examples": [
        "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6"
      ],
      "codeSnippet": "function maxSubArray(nums: number[]): number {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}",
      "createdAt": "2024-01-05T00:00:00.000Z",
      "updatedAt": "2024-01-05T00:00:00.000Z"
    },
    {
      "id": "6",
      "title": "6. Maximum Product Subarray (Dynamic Programming pattern)",
      "description": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dynamic-programming"
      ],
      "solution": "Track both maximum and minimum product at each position, as negative numbers can flip the sign.",
      "examples": [
        "Input: nums = [2,3,-2,4]\nOutput: 6"
      ],
      "codeSnippet": "function maxProduct(nums: number[]): number {\n  let maxProd = nums[0];\n  let minProd = nums[0];\n  let result = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const temp = maxProd;\n    maxProd = Math.max(nums[i], maxProd * nums[i], minProd * nums[i]);\n    minProd = Math.min(nums[i], temp * nums[i], minProd * nums[i]);\n    result = Math.max(result, maxProd);\n  }\n  return result;\n}",
      "createdAt": "2024-01-06T00:00:00.000Z",
      "updatedAt": "2024-01-06T00:00:00.000Z"
    },
    {
      "id": "7",
      "title": "7. Find Minimum in Rotated Sorted Array (Binary Search pattern)",
      "description": "Given the sorted rotated array nums of unique elements, return the minimum element of this array.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "binary-search"
      ],
      "solution": "Use binary search. Compare middle element with the rightmost element to determine which half to search.",
      "examples": [
        "Input: nums = [3,4,5,1,2]\nOutput: 1"
      ],
      "codeSnippet": "function findMin(nums: number[]): number {\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] > nums[right]) left = mid + 1;\n    else right = mid;\n  }\n  return nums[left];\n}",
      "createdAt": "2024-01-07T00:00:00.000Z",
      "updatedAt": "2024-01-07T00:00:00.000Z"
    },
    {
      "id": "8",
      "title": "8. Search in Rotated Sorted Array (Binary Search pattern)",
      "description": "Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "binary-search"
      ],
      "solution": "Use binary search with special handling for rotated array. Check which half is sorted.",
      "examples": [
        "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4"
      ],
      "codeSnippet": "function search(nums: number[], target: number): number {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) right = mid - 1;\n      else left = mid + 1;\n    } else {\n      if (target > nums[mid] && target <= nums[right]) left = mid + 1;\n      else right = mid - 1;\n    }\n  }\n  return -1;\n}",
      "createdAt": "2024-01-08T00:00:00.000Z",
      "updatedAt": "2024-01-08T00:00:00.000Z"
    },
    {
      "id": "9",
      "title": "9. 3Sum (Two Pointers pattern)",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "two-pointers"
      ],
      "solution": "Sort the array first. For each element, use two pointers to find pairs that sum to the negative of that element.",
      "examples": [
        "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]"
      ],
      "codeSnippet": "function threeSum(nums: number[]): number[][] {\n  nums.sort((a, b) => a - b);\n  const result: number[][] = [];\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i-1]) continue;\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left+1]) left++;\n        while (left < right && nums[right] === nums[right-1]) right--;\n        left++; right--;\n      } else if (sum < 0) left++;\n      else right--;\n    }\n  }\n  return result;\n}",
      "createdAt": "2024-01-09T00:00:00.000Z",
      "updatedAt": "2024-01-09T00:00:00.000Z"
    },
    {
      "id": "10",
      "title": "10. Container With Most Water (Two Pointers pattern)",
      "description": "You are given an integer array height of length n. Find two lines that together with the x-axis form a container, such that the container contains the most water.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "two-pointers"
      ],
      "solution": "Use two pointers at both ends. Move the pointer with the smaller height inward.",
      "examples": [
        "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49"
      ],
      "codeSnippet": "function maxArea(height: number[]): number {\n  let left = 0, right = height.length - 1;\n  let maxArea = 0;\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, area);\n    if (height[left] < height[right]) left++;\n    else right--;\n  }\n  return maxArea;\n}",
      "createdAt": "2024-01-10T00:00:00.000Z",
      "updatedAt": "2024-01-10T00:00:00.000Z"
    },
    {
      "id": "11",
      "title": "11. Sum of Two Integers (Bit Manipulation pattern)",
      "description": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "math",
        "bit-manipulation"
      ],
      "solution": "Use bitwise XOR for addition and AND with left shift for carry.",
      "examples": [
        "Input: a = 1, b = 2\nOutput: 3"
      ],
      "codeSnippet": "function getSum(a: number, b: number): number {\n  while (b !== 0) {\n    const carry = a & b;\n    a = a ^ b;\n    b = carry << 1;\n  }\n  return a;\n}",
      "createdAt": "2024-01-11T00:00:00.000Z",
      "updatedAt": "2024-01-11T00:00:00.000Z"
    },
    {
      "id": "12",
      "title": "12. Number of 1 Bits (Bit Manipulation pattern)",
      "description": "Write a function that takes an unsigned integer and returns the number of 1 bits it has.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "bit-manipulation"
      ],
      "solution": "Use bit manipulation. Count bits using n & (n-1) trick or right shift.",
      "examples": [
        "Input: n = 11\nOutput: 3"
      ],
      "codeSnippet": "function hammingWeight(n: number): number {\n  let count = 0;\n  while (n !== 0) {\n    count++;\n    n = n & (n - 1);\n  }\n  return count;\n}",
      "createdAt": "2024-01-12T00:00:00.000Z",
      "updatedAt": "2024-01-12T00:00:00.000Z"
    },
    {
      "id": "13",
      "title": "13. Counting Bits (Dynamic Programming pattern)",
      "description": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1s in the binary representation of i.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "dynamic-programming",
        "bit-manipulation"
      ],
      "solution": "Use dynamic programming. The number of 1s in i is equal to number of 1s in i/2 plus i % 2.",
      "examples": [
        "Input: n = 2\nOutput: [0,1,1]"
      ],
      "codeSnippet": "function countBits(n: number): number[] {\n  const result = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; i++) {\n    result[i] = result[i >> 1] + (i & 1);\n  }\n  return result;\n}",
      "createdAt": "2024-01-13T00:00:00.000Z",
      "updatedAt": "2024-01-13T00:00:00.000Z"
    },
    {
      "id": "14",
      "title": "14. Missing Number (Bit Manipulation pattern)",
      "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "array",
        "math",
        "bit-manipulation"
      ],
      "solution": "Use XOR operation or calculate expected sum vs actual sum.",
      "examples": [
        "Input: nums = [3,0,1]\nOutput: 2"
      ],
      "codeSnippet": "function missingNumber(nums: number[]): number {\n  let missing = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n    missing ^= i ^ nums[i];\n  }\n  return missing;\n}",
      "createdAt": "2024-01-14T00:00:00.000Z",
      "updatedAt": "2024-01-14T00:00:00.000Z"
    },
    {
      "id": "15",
      "title": "15. Reverse Bits (Bit Manipulation pattern)",
      "description": "Reverse bits of a given 32 bits unsigned integer.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "bit-manipulation"
      ],
      "solution": "Extract bits from right to left and build the reversed number.",
      "examples": [
        "Input: n = 43261596\nOutput: 964176192"
      ],
      "codeSnippet": "function reverseBits(n: number): number {\n  let result = 0;\n  for (let i = 0; i < 32; i++) {\n    result = (result << 1) | (n & 1);\n    n >>>= 1;\n  }\n  return result >>> 0;\n}",
      "createdAt": "2024-01-15T00:00:00.000Z",
      "updatedAt": "2024-01-15T00:00:00.000Z"
    },
    {
      "id": "16",
      "title": "16. Climbing Stairs (Dynamic Programming pattern)",
      "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "dynamic-programming",
        "math"
      ],
      "solution": "Use dynamic programming. Ways to reach step n = ways to reach step (n-1) + ways to reach step (n-2).",
      "examples": [
        "Input: n = 2\nOutput: 2"
      ],
      "codeSnippet": "function climbStairs(n: number): number {\n  if (n <= 2) return n;\n  let first = 1, second = 2;\n  for (let i = 3; i <= n; i++) {\n    const third = first + second;\n    first = second;\n    second = third;\n  }\n  return second;\n}",
      "createdAt": "2024-01-16T00:00:00.000Z",
      "updatedAt": "2024-01-16T00:00:00.000Z"
    },
    {
      "id": "17",
      "title": "17. Coin Change (Dynamic Programming pattern)",
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "dynamic-programming"
      ],
      "solution": "Use dynamic programming. For each amount, try all coins and take the minimum.",
      "examples": [
        "Input: coins = [1,2,5], amount = 11\nOutput: 3"
      ],
      "codeSnippet": "function coinChange(coins: number[], amount: number): number {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (let coin of coins) {\n      if (i >= coin) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
      "createdAt": "2024-01-17T00:00:00.000Z",
      "updatedAt": "2024-01-17T00:00:00.000Z"
    },
    {
      "id": "18",
      "title": "18. Longest Increasing Subsequence (Binary Search + DP pattern)",
      "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dynamic-programming",
        "binary-search"
      ],
      "solution": "Use dynamic programming with binary search for O(n log n) solution.",
      "examples": [
        "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4"
      ],
      "codeSnippet": "function lengthOfLIS(nums: number[]): number {\n  const tails: number[] = [];\n  for (let num of nums) {\n    let left = 0, right = tails.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) left = mid + 1;\n      else right = mid;\n    }\n    if (left === tails.length) tails.push(num);\n    else tails[left] = num;\n  }\n  return tails.length;\n}",
      "createdAt": "2024-01-18T00:00:00.000Z",
      "updatedAt": "2024-01-18T00:00:00.000Z"
    },
    {
      "id": "19",
      "title": "19. Longest Common Subsequence (Dynamic Programming pattern)",
      "description": "Given two strings text1 and text2, return the length of their longest common subsequence.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "dynamic-programming"
      ],
      "solution": "Use 2D dynamic programming. If characters match, add 1 to diagonal. Otherwise, take max of left or top.",
      "examples": [
        "Input: text1 = \"abcde\", text2 = \"ace\"\nOutput: 3"
      ],
      "codeSnippet": "function longestCommonSubsequence(text1: string, text2: string): number {\n  const m = text1.length, n = text2.length;\n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i-1] === text2[j-1]) {\n        dp[i][j] = dp[i-1][j-1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n      }\n    }\n  }\n  return dp[m][n];\n}",
      "createdAt": "2024-01-19T00:00:00.000Z",
      "updatedAt": "2024-01-19T00:00:00.000Z"
    },
    {
      "id": "20",
      "title": "20. Word Break Problem (Dynamic Programming pattern)",
      "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "dynamic-programming"
      ],
      "solution": "Use dynamic programming. For each position, check if substring ending there can be segmented.",
      "examples": [
        "Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true"
      ],
      "codeSnippet": "function wordBreak(s: string, wordDict: string[]): boolean {\n  const wordSet = new Set(wordDict);\n  const dp = new Array(s.length + 1).fill(false);\n  dp[0] = true;\n  for (let i = 1; i <= s.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  return dp[s.length];\n}",
      "createdAt": "2024-01-20T00:00:00.000Z",
      "updatedAt": "2024-01-20T00:00:00.000Z"
    },
    {
      "id": "21",
      "title": "21. Combination Sum (Backtracking pattern)",
      "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "backtracking"
      ],
      "solution": "Use backtracking. Try each candidate and recursively solve for remaining target.",
      "examples": [
        "Input: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]"
      ],
      "codeSnippet": "function combinationSum(candidates: number[], target: number): number[][] {\n  const result: number[][] = [];\n  function backtrack(remaining: number, combo: number[], start: number) {\n    if (remaining === 0) {\n      result.push([...combo]);\n      return;\n    }\n    for (let i = start; i < candidates.length; i++) {\n      if (candidates[i] > remaining) continue;\n      combo.push(candidates[i]);\n      backtrack(remaining - candidates[i], combo, i);\n      combo.pop();\n    }\n  }\n  backtrack(target, [], 0);\n  return result;\n}",
      "createdAt": "2024-01-21T00:00:00.000Z",
      "updatedAt": "2024-01-21T00:00:00.000Z"
    },
    {
      "id": "22",
      "title": "22. House Robber (Dynamic Programming pattern)",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, return the maximum amount of money you can rob tonight.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dynamic-programming"
      ],
      "solution": "Use dynamic programming. At each house, decide to rob or skip based on maximum profit.",
      "examples": [
        "Input: nums = [1,2,3,1]\nOutput: 4"
      ],
      "codeSnippet": "function rob(nums: number[]): number {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  const dp = new Array(nums.length);\n  dp[0] = nums[0];\n  dp[1] = Math.max(nums[0], nums[1]);\n  for (let i = 2; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n  }\n  return dp[nums.length - 1];\n}",
      "createdAt": "2024-01-22T00:00:00.000Z",
      "updatedAt": "2024-01-22T00:00:00.000Z"
    },
    {
      "id": "23",
      "title": "23. House Robber II (Dynamic Programming pattern)",
      "description": "You are a professional robber planning to rob houses along a street, arranged in a circle. Return the maximum amount of money you can rob tonight.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dynamic-programming"
      ],
      "solution": "Similar to House Robber, but handle circular array by solving for [0, n-2] and [1, n-1] separately.",
      "examples": [
        "Input: nums = [2,3,2]\nOutput: 3"
      ],
      "codeSnippet": "function rob(nums: number[]): number {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  return Math.max(robHelper(nums.slice(0, -1)), robHelper(nums.slice(1)));\n}\nfunction robHelper(nums: number[]): number {\n  let prev = 0, curr = 0;\n  for (let num of nums) {\n    const temp = Math.max(curr, prev + num);\n    prev = curr;\n    curr = temp;\n  }\n  return curr;\n}",
      "createdAt": "2024-01-23T00:00:00.000Z",
      "updatedAt": "2024-01-23T00:00:00.000Z"
    },
    {
      "id": "24",
      "title": "24. Decode Ways (Dynamic Programming pattern)",
      "description": "A message containing letters from A-Z can be encoded into numbers. Given a string s containing only digits, return the number of ways to decode it.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "dynamic-programming"
      ],
      "solution": "Use dynamic programming. For each position, check if single digit or two digits form valid code.",
      "examples": [
        "Input: s = \"12\"\nOutput: 2"
      ],
      "codeSnippet": "function numDecodings(s: string): number {\n  const dp = new Array(s.length + 1).fill(0);\n  dp[0] = 1;\n  dp[1] = s[0] === \"0\" ? 0 : 1;\n  for (let i = 2; i <= s.length; i++) {\n    const oneDigit = parseInt(s.substring(i-1, i));\n    const twoDigits = parseInt(s.substring(i-2, i));\n    if (oneDigit >= 1) dp[i] += dp[i-1];\n    if (twoDigits >= 10 && twoDigits <= 26) dp[i] += dp[i-2];\n  }\n  return dp[s.length];\n}",
      "createdAt": "2024-01-24T00:00:00.000Z",
      "updatedAt": "2024-01-24T00:00:00.000Z"
    },
    {
      "id": "25",
      "title": "25. Unique Paths (Dynamic Programming pattern)",
      "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner. How many possible unique paths are there?",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "math",
        "dynamic-programming"
      ],
      "solution": "Use dynamic programming. Paths to (i,j) = paths to (i-1,j) + paths to (i,j-1).",
      "examples": [
        "Input: m = 3, n = 7\nOutput: 28"
      ],
      "codeSnippet": "function uniquePaths(m: number, n: number): number {\n  const dp = Array(m).fill(null).map(() => Array(n).fill(1));\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i-1][j] + dp[i][j-1];\n    }\n  }\n  return dp[m-1][n-1];\n}",
      "createdAt": "2024-01-25T00:00:00.000Z",
      "updatedAt": "2024-01-25T00:00:00.000Z"
    },
    {
      "id": "26",
      "title": "26. Jump Game (Greedy pattern)",
      "description": "You are given an integer array nums. You are initially positioned at the arrays first index. Return true if you can reach the last index, or false otherwise.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "greedy"
      ],
      "solution": "Use greedy approach. Track the farthest position you can reach.",
      "examples": [
        "Input: nums = [2,3,1,1,4]\nOutput: true"
      ],
      "codeSnippet": "function canJump(nums: number[]): boolean {\n  let farthest = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > farthest) return false;\n    farthest = Math.max(farthest, i + nums[i]);\n    if (farthest >= nums.length - 1) return true;\n  }\n  return true;\n}",
      "createdAt": "2024-01-26T00:00:00.000Z",
      "updatedAt": "2024-01-26T00:00:00.000Z"
    },
    {
      "id": "27",
      "title": "27. Clone Graph (DFS/BFS pattern)",
      "description": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "graph",
        "hash-table",
        "dfs"
      ],
      "solution": "Use DFS or BFS with a hash map to store cloned nodes.",
      "examples": [
        "Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]"
      ],
      "codeSnippet": "function cloneGraph(node: Node | null): Node | null {\n  if (!node) return null;\n  const map = new Map<Node, Node>();\n  function dfs(original: Node): Node {\n    if (map.has(original)) return map.get(original)!;\n    const clone = new Node(original.val);\n    map.set(original, clone);\n    for (let neighbor of original.neighbors) {\n      clone.neighbors.push(dfs(neighbor));\n    }\n    return clone;\n  }\n  return dfs(node);\n}",
      "createdAt": "2024-01-27T00:00:00.000Z",
      "updatedAt": "2024-01-27T00:00:00.000Z"
    },
    {
      "id": "28",
      "title": "28. Course Schedule (Topological Sort pattern)",
      "description": "There are a total of numCourses courses you have to take. Some courses may have prerequisites. Return true if you can finish all courses.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "graph",
        "topological-sort"
      ],
      "solution": "Use topological sort (Kahn algorithm) or DFS to detect cycles.",
      "examples": [
        "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true"
      ],
      "codeSnippet": "function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n  const graph = Array(numCourses).fill(null).map(() => []);\n  const indegree = new Array(numCourses).fill(0);\n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    indegree[course]++;\n  }\n  const queue: number[] = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (indegree[i] === 0) queue.push(i);\n  }\n  let count = 0;\n  while (queue.length > 0) {\n    const course = queue.shift()!;\n    count++;\n    for (let next of graph[course]) {\n      indegree[next]--;\n      if (indegree[next] === 0) queue.push(next);\n    }\n  }\n  return count === numCourses;\n}",
      "createdAt": "2024-01-28T00:00:00.000Z",
      "updatedAt": "2024-01-28T00:00:00.000Z"
    },
    {
      "id": "29",
      "title": "29. Pacific Atlantic Water Flow (DFS pattern)",
      "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. Find the list of grid coordinates where water can flow to both oceans.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dfs",
        "bfs"
      ],
      "solution": "Start DFS from all border cells. Mark cells reachable from Pacific and Atlantic separately, then find intersection.",
      "examples": [
        "Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
      ],
      "codeSnippet": "function pacificAtlantic(heights: number[][]): number[][] {\n  const m = heights.length, n = heights[0].length;\n  const pacific = Array(m).fill(null).map(() => Array(n).fill(false));\n  const atlantic = Array(m).fill(null).map(() => Array(n).fill(false));\n  function dfs(r: number, c: number, ocean: boolean[][], prevHeight: number) {\n    if (r < 0 || r >= m || c < 0 || c >= n || ocean[r][c] || heights[r][c] < prevHeight) return;\n    ocean[r][c] = true;\n    dfs(r+1, c, ocean, heights[r][c]);\n    dfs(r-1, c, ocean, heights[r][c]);\n    dfs(r, c+1, ocean, heights[r][c]);\n    dfs(r, c-1, ocean, heights[r][c]);\n  }\n  for (let i = 0; i < m; i++) {\n    dfs(i, 0, pacific, -1);\n    dfs(i, n-1, atlantic, -1);\n  }\n  for (let j = 0; j < n; j++) {\n    dfs(0, j, pacific, -1);\n    dfs(m-1, j, atlantic, -1);\n  }\n  const result: number[][] = [];\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (pacific[i][j] && atlantic[i][j]) result.push([i, j]);\n    }\n  }\n  return result;\n}",
      "createdAt": "2024-01-29T00:00:00.000Z",
      "updatedAt": "2024-01-29T00:00:00.000Z"
    },
    {
      "id": "30",
      "title": "30. Number of Islands (DFS/BFS pattern)",
      "description": "Given an m x n 2D binary grid which represents a map of 1s (land) and 0s (water), return the number of islands.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "dfs",
        "bfs"
      ],
      "solution": "Use DFS or BFS. For each 1 found, mark all connected 1s as visited.",
      "examples": [
        "Input: grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]\nOutput: 1"
      ],
      "codeSnippet": "function numIslands(grid: string[][]): number {\n  let count = 0;\n  function dfs(r: number, c: number) {\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] === \"0\") return;\n    grid[r][c] = \"0\";\n    dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1);\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === \"1\") {\n        count++;\n        dfs(i, j);\n      }\n    }\n  }\n  return count;\n}",
      "createdAt": "2024-01-30T00:00:00.000Z",
      "updatedAt": "2024-01-30T00:00:00.000Z"
    },
    {
      "id": "31",
      "title": "31. Longest Consecutive Sequence (Hashmap pattern)",
      "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "hash-table"
      ],
      "solution": "Use hash set. For each number, check if it starts a sequence by checking if num-1 exists.",
      "examples": [
        "Input: nums = [100,4,200,1,3,2]\nOutput: 4"
      ],
      "codeSnippet": "function longestConsecutive(nums: number[]): number {\n  const numSet = new Set(nums);\n  let longest = 0;\n  for (let num of numSet) {\n    if (!numSet.has(num - 1)) {\n      let length = 1;\n      while (numSet.has(num + length)) length++;\n      longest = Math.max(longest, length);\n    }\n  }\n  return longest;\n}",
      "createdAt": "2024-01-31T00:00:00.000Z",
      "updatedAt": "2024-01-31T00:00:00.000Z"
    },
    {
      "id": "32",
      "title": "32. Alien Dictionary (Topological Sort pattern)",
      "description": "There is a new alien language that uses the English alphabet. However, the order among letters is unknown. Derive the order of letters in this language.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "graph",
        "topological-sort"
      ],
      "solution": "Build a graph from word comparisons, then use topological sort.",
      "examples": [
        "Input: words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\nOutput: \"wertf\""
      ],
      "codeSnippet": "function alienOrder(words: string[]): string {\n  const graph = new Map<string, Set<string>>();\n  const indegree = new Map<string, number>();\n  for (let word of words) {\n    for (let char of word) {\n      if (!graph.has(char)) graph.set(char, new Set());\n      if (!indegree.has(char)) indegree.set(char, 0);\n    }\n  }\n  for (let i = 0; i < words.length - 1; i++) {\n    const w1 = words[i], w2 = words[i+1];\n    if (w1.length > w2.length && w1.startsWith(w2)) return \"\";\n    for (let j = 0; j < Math.min(w1.length, w2.length); j++) {\n      if (w1[j] !== w2[j]) {\n        if (!graph.get(w1[j])!.has(w2[j])) {\n          graph.get(w1[j])!.add(w2[j]);\n          indegree.set(w2[j], indegree.get(w2[j])! + 1);\n        }\n        break;\n      }\n    }\n  }\n  const queue: string[] = [];\n  for (let [char, degree] of indegree) {\n    if (degree === 0) queue.push(char);\n  }\n  let result = \"\";\n  while (queue.length > 0) {\n    const char = queue.shift()!;\n    result += char;\n    for (let next of graph.get(char) || []) {\n      indegree.set(next, indegree.get(next)! - 1);\n      if (indegree.get(next) === 0) queue.push(next);\n    }\n  }\n  return result.length === indegree.size ? result : \"\";\n}",
      "createdAt": "2024-01-32T00:00:00.000Z",
      "updatedAt": "2024-01-32T00:00:00.000Z"
    },
    {
      "id": "33",
      "title": "33. Graph Valid Tree (Union Find pattern)",
      "description": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges, write a function to check whether these edges make up a valid tree.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "graph",
        "union-find"
      ],
      "solution": "Use union-find or DFS. A valid tree has n-1 edges and is connected.",
      "examples": [
        "Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true"
      ],
      "codeSnippet": "function validTree(n: number, edges: number[][]): boolean {\n  if (edges.length !== n - 1) return false;\n  const parent = Array(n).fill(null).map((_, i) => i);\n  function find(x: number): number {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n  function union(x: number, y: number): boolean {\n    const px = find(x), py = find(y);\n    if (px === py) return false;\n    parent[px] = py;\n    return true;\n  }\n  for (let [u, v] of edges) {\n    if (!union(u, v)) return false;\n  }\n  return true;\n}",
      "createdAt": "2024-01-33T00:00:00.000Z",
      "updatedAt": "2024-01-33T00:00:00.000Z"
    },
    {
      "id": "34",
      "title": "34. Number of Connected Components (Union Find pattern)",
      "description": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges, find the number of connected components in an undirected graph.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "graph",
        "union-find",
        "dfs"
      ],
      "solution": "Use union-find or DFS to count connected components.",
      "examples": [
        "Input: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2"
      ],
      "codeSnippet": "function countComponents(n: number, edges: number[][]): number {\n  const parent = Array(n).fill(null).map((_, i) => i);\n  function find(x: number): number {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n  function union(x: number, y: number) {\n    parent[find(x)] = find(y);\n  }\n  for (let [u, v] of edges) union(u, v);\n  const components = new Set();\n  for (let i = 0; i < n; i++) components.add(find(i));\n  return components.size;\n}",
      "createdAt": "2024-01-34T00:00:00.000Z",
      "updatedAt": "2024-01-34T00:00:00.000Z"
    },
    {
      "id": "35",
      "title": "35. Insert Interval (Intervals pattern)",
      "description": "You are given an array of non-overlapping intervals where intervals[i] = [starti, endi]. Insert newInterval into intervals such that intervals is still sorted and non-overlapping.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array"
      ],
      "solution": "Insert the interval and merge overlapping intervals.",
      "examples": [
        "Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]"
      ],
      "codeSnippet": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n  const result: number[][] = [];\n  let i = 0;\n  while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i++]);\n  }\n  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n  while (i < intervals.length) result.push(intervals[i++]);\n  return result;\n}",
      "createdAt": "2024-01-35T00:00:00.000Z",
      "updatedAt": "2024-01-35T00:00:00.000Z"
    },
    {
      "id": "36",
      "title": "36. Merge Intervals (Intervals pattern)",
      "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "sorting"
      ],
      "solution": "Sort by start time, then merge overlapping intervals.",
      "examples": [
        "Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]"
      ],
      "codeSnippet": "function merge(intervals: number[][]): number[][] {\n  intervals.sort((a, b) => a[0] - b[0]);\n  const merged: number[][] = [intervals[0]];\n  for (let i = 1; i < intervals.length; i++) {\n    const last = merged[merged.length - 1];\n    if (intervals[i][0] <= last[1]) {\n      last[1] = Math.max(last[1], intervals[i][1]);\n    } else {\n      merged.push(intervals[i]);\n    }\n  }\n  return merged;\n}",
      "createdAt": "2024-01-36T00:00:00.000Z",
      "updatedAt": "2024-01-36T00:00:00.000Z"
    },
    {
      "id": "37",
      "title": "37. Non-overlapping Intervals (Greedy pattern)",
      "description": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "greedy",
        "sorting"
      ],
      "solution": "Sort by end time. Greedily keep intervals that end earliest.",
      "examples": [
        "Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1"
      ],
      "codeSnippet": "function eraseOverlapIntervals(intervals: number[][]): number {\n  intervals.sort((a, b) => a[1] - b[1]);\n  let count = 0, end = intervals[0][1];\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < end) count++;\n    else end = intervals[i][1];\n  }\n  return count;\n}",
      "createdAt": "2024-01-37T00:00:00.000Z",
      "updatedAt": "2024-01-37T00:00:00.000Z"
    },
    {
      "id": "38",
      "title": "38. Meeting Rooms (Intervals pattern)",
      "description": "Given an array of meeting time intervals, determine if a person could attend all meetings.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "array",
        "sorting"
      ],
      "solution": "Sort by start time and check if any interval overlaps with the next.",
      "examples": [
        "Input: intervals = [[0,30],[5,10],[15,20]]\nOutput: false"
      ],
      "codeSnippet": "function canAttendMeetings(intervals: number[][]): boolean {\n  intervals.sort((a, b) => a[0] - b[0]);\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < intervals[i-1][1]) return false;\n  }\n  return true;\n}",
      "createdAt": "2024-01-38T00:00:00.000Z",
      "updatedAt": "2024-01-38T00:00:00.000Z"
    },
    {
      "id": "39",
      "title": "39. Meeting Rooms II (Heap pattern)",
      "description": "Given an array of meeting time intervals, find the minimum number of conference rooms required.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "heap",
        "greedy"
      ],
      "solution": "Use min heap to track end times of meetings. Sort by start time.",
      "examples": [
        "Input: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2"
      ],
      "codeSnippet": "function minMeetingRooms(intervals: number[][]): number {\n  intervals.sort((a, b) => a[0] - b[0]);\n  const heap: number[] = [];\n  for (let [start, end] of intervals) {\n    if (heap.length > 0 && heap[0] <= start) {\n      heap.shift();\n    }\n    heap.push(end);\n    heap.sort((a, b) => a - b);\n  }\n  return heap.length;\n}",
      "createdAt": "2024-01-39T00:00:00.000Z",
      "updatedAt": "2024-01-39T00:00:00.000Z"
    },
    {
      "id": "40",
      "title": "40. Reverse Linked List (Linked List pattern)",
      "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "linked-list",
        "recursion"
      ],
      "solution": "Iterate through the list, reversing pointers. Use three pointers: prev, current, and next.",
      "examples": [
        "Input: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]"
      ],
      "codeSnippet": "function reverseList(head: ListNode | null): ListNode | null {\n  let prev: ListNode | null = null;\n  let current = head;\n  while (current !== null) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  return prev;\n}",
      "createdAt": "2024-01-40T00:00:00.000Z",
      "updatedAt": "2024-01-40T00:00:00.000Z"
    },
    {
      "id": "41",
      "title": "41. Detect Cycle in Linked List (Two Pointers pattern)",
      "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "linked-list",
        "two-pointers"
      ],
      "solution": "Use Floyds cycle detection algorithm (tortoise and hare).",
      "examples": [
        "Input: head = [3,2,0,-4], pos = 1\nOutput: true"
      ],
      "codeSnippet": "function hasCycle(head: ListNode | null): boolean {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow!.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}",
      "createdAt": "2024-01-41T00:00:00.000Z",
      "updatedAt": "2024-01-41T00:00:00.000Z"
    },
    {
      "id": "42",
      "title": "42. Merge Two Sorted Lists (Linked List pattern)",
      "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "linked-list"
      ],
      "solution": "Use two pointers, compare values and merge.",
      "examples": [
        "Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]"
      ],
      "codeSnippet": "function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  while (list1 && list2) {\n    if (list1.val < list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  current.next = list1 || list2;\n  return dummy.next;\n}",
      "createdAt": "2024-01-42T00:00:00.000Z",
      "updatedAt": "2024-01-42T00:00:00.000Z"
    },
    {
      "id": "43",
      "title": "43. Merge K Sorted Lists (Heap/Divide & Conquer pattern)",
      "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "linked-list",
        "heap",
        "divide-conquer"
      ],
      "solution": "Use min heap to always get the smallest node, or use divide and conquer merge.",
      "examples": [
        "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]"
      ],
      "codeSnippet": "function mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n  if (lists.length === 0) return null;\n  while (lists.length > 1) {\n    const merged: Array<ListNode | null> = [];\n    for (let i = 0; i < lists.length; i += 2) {\n      const l1 = lists[i];\n      const l2 = i + 1 < lists.length ? lists[i + 1] : null;\n      merged.push(mergeTwoLists(l1, l2));\n    }\n    lists = merged;\n  }\n  return lists[0];\n}",
      "createdAt": "2024-01-43T00:00:00.000Z",
      "updatedAt": "2024-01-43T00:00:00.000Z"
    },
    {
      "id": "44",
      "title": "44. Remove Nth Node From End (Two Pointers pattern)",
      "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "linked-list",
        "two-pointers"
      ],
      "solution": "Use two pointers. Move first pointer n steps ahead, then move both until first reaches end.",
      "examples": [
        "Input: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]"
      ],
      "codeSnippet": "function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n  const dummy = new ListNode(0);\n  dummy.next = head;\n  let first = dummy, second = dummy;\n  for (let i = 0; i <= n; i++) first = first.next!;\n  while (first) {\n    first = first.next!;\n    second = second.next!;\n  }\n  second.next = second.next!.next;\n  return dummy.next;\n}",
      "createdAt": "2024-01-44T00:00:00.000Z",
      "updatedAt": "2024-01-44T00:00:00.000Z"
    },
    {
      "id": "45",
      "title": "45. Reorder List (Linked List pattern)",
      "description": "You are given the head of a singly linked-list. Reorder the list to be on the following form: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "linked-list",
        "two-pointers"
      ],
      "solution": "Find middle, reverse second half, then merge the two halves.",
      "examples": [
        "Input: head = [1,2,3,4]\nOutput: [1,4,2,3]"
      ],
      "codeSnippet": "function reorderList(head: ListNode | null): void {\n  if (!head || !head.next) return;\n  let slow = head, fast = head;\n  while (fast.next && fast.next.next) {\n    slow = slow.next!;\n    fast = fast.next.next;\n  }\n  let second = slow.next;\n  slow.next = null;\n  let prev: ListNode | null = null;\n  while (second) {\n    const next = second.next;\n    second.next = prev;\n    prev = second;\n    second = next;\n  }\n  let first = head;\n  second = prev;\n  while (second) {\n    const temp1 = first.next, temp2 = second.next;\n    first.next = second;\n    second.next = temp1;\n    first = temp1!;\n    second = temp2;\n  }\n}",
      "createdAt": "2024-01-45T00:00:00.000Z",
      "updatedAt": "2024-01-45T00:00:00.000Z"
    },
    {
      "id": "46",
      "title": "46. Set Matrix Zeroes (Matrix pattern)",
      "description": "Given an m x n integer matrix, if an element is 0, set its entire row and column to 0s.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "matrix"
      ],
      "solution": "Use first row and column as markers. Handle first row and column separately.",
      "examples": [
        "Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]"
      ],
      "codeSnippet": "function setZeroes(matrix: number[][]): void {\n  const m = matrix.length, n = matrix[0].length;\n  let firstRowZero = false, firstColZero = false;\n  for (let i = 0; i < m; i++) if (matrix[i][0] === 0) firstColZero = true;\n  for (let j = 0; j < n; j++) if (matrix[0][j] === 0) firstRowZero = true;\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][j] === 0) {\n        matrix[i][0] = 0;\n        matrix[0][j] = 0;\n      }\n    }\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\n    }\n  }\n  if (firstRowZero) for (let j = 0; j < n; j++) matrix[0][j] = 0;\n  if (firstColZero) for (let i = 0; i < m; i++) matrix[i][0] = 0;\n}",
      "createdAt": "2024-01-46T00:00:00.000Z",
      "updatedAt": "2024-01-46T00:00:00.000Z"
    },
    {
      "id": "47",
      "title": "47. Spiral Matrix (Matrix pattern)",
      "description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "matrix"
      ],
      "solution": "Use four boundaries: top, bottom, left, right. Traverse in spiral order.",
      "examples": [
        "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]"
      ],
      "codeSnippet": "function spiralOrder(matrix: number[][]): number[] {\n  const result: number[] = [];\n  let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;\n  while (top <= bottom && left <= right) {\n    for (let j = left; j <= right; j++) result.push(matrix[top][j]);\n    top++;\n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n    if (top <= bottom) {\n      for (let j = right; j >= left; j--) result.push(matrix[bottom][j]);\n      bottom--;\n    }\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return result;\n}",
      "createdAt": "2024-01-47T00:00:00.000Z",
      "updatedAt": "2024-01-47T00:00:00.000Z"
    },
    {
      "id": "48",
      "title": "48. Rotate Image (Matrix pattern)",
      "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "matrix"
      ],
      "solution": "Transpose the matrix, then reverse each row.",
      "examples": [
        "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]"
      ],
      "codeSnippet": "function rotate(matrix: number[][]): void {\n  const n = matrix.length;\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse();\n  }\n}",
      "createdAt": "2024-01-48T00:00:00.000Z",
      "updatedAt": "2024-01-48T00:00:00.000Z"
    },
    {
      "id": "49",
      "title": "49. Word Search (Backtracking pattern)",
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "backtracking",
        "dfs"
      ],
      "solution": "Use backtracking with DFS. Mark visited cells and backtrack.",
      "examples": [
        "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true"
      ],
      "codeSnippet": "function exist(board: string[][], word: string): boolean {\n  const m = board.length, n = board[0].length;\n  function dfs(r: number, c: number, index: number): boolean {\n    if (index === word.length) return true;\n    if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== word[index]) return false;\n    const temp = board[r][c];\n    board[r][c] = \"#\";\n    const found = dfs(r+1, c, index+1) || dfs(r-1, c, index+1) || dfs(r, c+1, index+1) || dfs(r, c-1, index+1);\n    board[r][c] = temp;\n    return found;\n  }\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (dfs(i, j, 0)) return true;\n    }\n  }\n  return false;\n}",
      "createdAt": "2024-01-49T00:00:00.000Z",
      "updatedAt": "2024-01-49T00:00:00.000Z"
    },
    {
      "id": "50",
      "title": "50. Longest Substring Without Repeating Characters (Sliding Window pattern)",
      "description": "Given a string s, find the length of the longest substring without repeating characters.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "sliding-window"
      ],
      "solution": "Use sliding window with hash set to track characters in current window.",
      "examples": [
        "Input: s = \"abcabcbb\"\nOutput: 3"
      ],
      "codeSnippet": "function lengthOfLongestSubstring(s: string): number {\n  const map = new Map<string, number>();\n  let maxLen = 0, start = 0;\n  for (let end = 0; end < s.length; end++) {\n    if (map.has(s[end]) && map.get(s[end])! >= start) {\n      start = map.get(s[end])! + 1;\n    }\n    map.set(s[end], end);\n    maxLen = Math.max(maxLen, end - start + 1);\n  }\n  return maxLen;\n}",
      "createdAt": "2024-01-50T00:00:00.000Z",
      "updatedAt": "2024-01-50T00:00:00.000Z"
    },
    {
      "id": "51",
      "title": "51. Longest Repeating Character Replacement (Sliding Window pattern)",
      "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. Find the length of the longest substring containing the same letter.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "sliding-window"
      ],
      "solution": "Use sliding window. Track character frequencies and check if window can be made valid with k replacements.",
      "examples": [
        "Input: s = \"ABAB\", k = 2\nOutput: 4"
      ],
      "codeSnippet": "function characterReplacement(s: string, k: number): number {\n  const count = new Map<string, number>();\n  let maxCount = 0, maxLength = 0, left = 0;\n  for (let right = 0; right < s.length; right++) {\n    count.set(s[right], (count.get(s[right]) || 0) + 1);\n    maxCount = Math.max(maxCount, count.get(s[right])!);\n    if (right - left + 1 - maxCount > k) {\n      count.set(s[left], count.get(s[left])! - 1);\n      left++;\n    }\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n  return maxLength;\n}",
      "createdAt": "2024-01-51T00:00:00.000Z",
      "updatedAt": "2024-01-51T00:00:00.000Z"
    },
    {
      "id": "52",
      "title": "52. Minimum Window Substring (Sliding Window pattern)",
      "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t is included in the window.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "string",
        "sliding-window"
      ],
      "solution": "Use sliding window. Expand right until all characters are included, then shrink left.",
      "examples": [
        "Input: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\""
      ],
      "codeSnippet": "function minWindow(s: string, t: string): string {\n  const need = new Map<string, number>();\n  for (let char of t) need.set(char, (need.get(char) || 0) + 1);\n  let left = 0, right = 0, valid = 0;\n  const window = new Map<string, number>();\n  let start = 0, len = Infinity;\n  while (right < s.length) {\n    const c = s[right];\n    right++;\n    if (need.has(c)) {\n      window.set(c, (window.get(c) || 0) + 1);\n      if (window.get(c) === need.get(c)) valid++;\n    }\n    while (valid === need.size) {\n      if (right - left < len) {\n        start = left;\n        len = right - left;\n      }\n      const d = s[left];\n      left++;\n      if (need.has(d)) {\n        if (window.get(d) === need.get(d)) valid--;\n        window.set(d, window.get(d)! - 1);\n      }\n    }\n  }\n  return len === Infinity ? \"\" : s.substring(start, start + len);\n}",
      "createdAt": "2024-01-52T00:00:00.000Z",
      "updatedAt": "2024-01-52T00:00:00.000Z"
    },
    {
      "id": "53",
      "title": "53. Valid Anagram (Hashmap pattern)",
      "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "string",
        "hash-table"
      ],
      "solution": "Count character frequencies in both strings and compare.",
      "examples": [
        "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true"
      ],
      "codeSnippet": "function isAnagram(s: string, t: string): boolean {\n  if (s.length !== t.length) return false;\n  const count = new Array(26).fill(0);\n  for (let i = 0; i < s.length; i++) {\n    count[s.charCodeAt(i) - 97]++;\n    count[t.charCodeAt(i) - 97]--;\n  }\n  return count.every(c => c === 0);\n}",
      "createdAt": "2024-01-53T00:00:00.000Z",
      "updatedAt": "2024-01-53T00:00:00.000Z"
    },
    {
      "id": "54",
      "title": "54. Group Anagrams (Hashmap pattern)",
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "hash-table"
      ],
      "solution": "Group strings by their sorted character representation.",
      "examples": [
        "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
      ],
      "codeSnippet": "function groupAnagrams(strs: string[]): string[][] {\n  const map = new Map<string, string[]>()\n  for (let str of strs) {\n    const key = str.split(\"\").sort().join(\"\");\n    if (!map.has(key)) map.set(key, []);\n    map.get(key)!.push(str);\n  }\n  return Array.from(map.values());\n}",
      "createdAt": "2024-01-54T00:00:00.000Z",
      "updatedAt": "2024-01-54T00:00:00.000Z"
    },
    {
      "id": "55",
      "title": "55. Valid Parentheses (Stack pattern)",
      "description": "Given a string s containing just the characters ( ), { }, and [ ], determine if the input string is valid.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "string",
        "stack"
      ],
      "solution": "Use stack. Push opening brackets, pop when matching closing bracket.",
      "examples": [
        "Input: s = \"()\"\nOutput: true"
      ],
      "codeSnippet": "function isValid(s: string): boolean {\n  const stack: string[] = [];\n  const pairs: Record<string, string> = { \"(\": \")\", \"[\": \"]\", \"{\": \"}\" };\n  for (let char of s) {\n    if (pairs[char]) stack.push(char);\n    else if (stack.length === 0 || pairs[stack.pop()!] !== char) return false;\n  }\n  return stack.length === 0;\n}",
      "createdAt": "2024-01-55T00:00:00.000Z",
      "updatedAt": "2024-01-55T00:00:00.000Z"
    },
    {
      "id": "56",
      "title": "56. Valid Palindrome (Two Pointers pattern)",
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "string",
        "two-pointers"
      ],
      "solution": "Use two pointers, one from start and one from end, skip non-alphanumeric.",
      "examples": [
        "Input: s = \"A man, a plan, a canal: Panama\"\nOutput: true"
      ],
      "codeSnippet": "function isPalindrome(s: string): boolean {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    while (left < right && !/[a-zA-Z0-9]/.test(s[left])) left++;\n    while (left < right && !/[a-zA-Z0-9]/.test(s[right])) right--;\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) return false;\n    left++; right--;\n  }\n  return true;\n}",
      "createdAt": "2024-01-56T00:00:00.000Z",
      "updatedAt": "2024-01-56T00:00:00.000Z"
    },
    {
      "id": "57",
      "title": "57. Longest Palindromic Substring (Two Pointers pattern)",
      "description": "Given a string s, return the longest palindromic substring in s.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "dynamic-programming"
      ],
      "solution": "Expand around centers. Check both odd and even length palindromes.",
      "examples": [
        "Input: s = \"babad\"\nOutput: \"bab\""
      ],
      "codeSnippet": "function longestPalindrome(s: string): string {\n  let start = 0, maxLen = 0;\n  function expandAroundCenter(left: number, right: number) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--; right++;\n    }\n    if (right - left - 1 > maxLen) {\n      start = left + 1;\n      maxLen = right - left - 1;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    expandAroundCenter(i, i);\n    expandAroundCenter(i, i + 1);\n  }\n  return s.substring(start, start + maxLen);\n}",
      "createdAt": "2024-01-57T00:00:00.000Z",
      "updatedAt": "2024-01-57T00:00:00.000Z"
    },
    {
      "id": "58",
      "title": "58. Palindromic Substrings (Two Pointers pattern)",
      "description": "Given a string s, return the number of palindromic substrings in it.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "dynamic-programming"
      ],
      "solution": "Similar to longest palindromic substring, count all palindromes.",
      "examples": [
        "Input: s = \"abc\"\nOutput: 3"
      ],
      "codeSnippet": "function countSubstrings(s: string): number {\n  let count = 0;\n  function expandAroundCenter(left: number, right: number) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      count++;\n      left--; right++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    expandAroundCenter(i, i);\n    expandAroundCenter(i, i + 1);\n  }\n  return count;\n}",
      "createdAt": "2024-01-58T00:00:00.000Z",
      "updatedAt": "2024-01-58T00:00:00.000Z"
    },
    {
      "id": "59",
      "title": "59. Encode and Decode Strings (String Encoding pattern)",
      "description": "Design an algorithm to encode a list of strings to a string and decode the string back to the original list of strings.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "string",
        "design"
      ],
      "solution": "Encode with length prefix and delimiter. Decode by reading length first.",
      "examples": [
        "Input: [\"Hello\",\"World\"]\nOutput: \"5#Hello5#World\""
      ],
      "codeSnippet": "function encode(strs: string[]): string {\n  return strs.map(s => `${s.length}#${s}`).join(\"\");\n}\nfunction decode(s: string): string[] {\n  const result: string[] = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (s[j] !== \"#\") j++;\n    const len = parseInt(s.substring(i, j));\n    result.push(s.substring(j + 1, j + 1 + len));\n    i = j + 1 + len;\n  }\n  return result;\n}",
      "createdAt": "2024-01-59T00:00:00.000Z",
      "updatedAt": "2024-01-59T00:00:00.000Z"
    },
    {
      "id": "60",
      "title": "60. Maximum Depth of Binary Tree (DFS pattern)",
      "description": "Given the root of a binary tree, return its maximum depth.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Recursively calculate max depth of left and right subtrees.",
      "examples": [
        "Input: root = [3,9,20,null,null,15,7]\nOutput: 3"
      ],
      "codeSnippet": "function maxDepth(root: TreeNode | null): number {\n  if (!root) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}",
      "createdAt": "2024-01-60T00:00:00.000Z",
      "updatedAt": "2024-01-60T00:00:00.000Z"
    },
    {
      "id": "61",
      "title": "61. Same Tree (DFS pattern)",
      "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Recursively compare nodes and their children.",
      "examples": [
        "Input: p = [1,2,3], q = [1,2,3]\nOutput: true"
      ],
      "codeSnippet": "function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
      "createdAt": "2024-01-61T00:00:00.000Z",
      "updatedAt": "2024-01-61T00:00:00.000Z"
    },
    {
      "id": "62",
      "title": "62. Invert Binary Tree (DFS pattern)",
      "description": "Given the root of a binary tree, invert the tree, and return its root.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Recursively swap left and right children.",
      "examples": [
        "Input: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]"
      ],
      "codeSnippet": "function invertTree(root: TreeNode | null): TreeNode | null {\n  if (!root) return null;\n  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];\n  return root;\n}",
      "createdAt": "2024-01-62T00:00:00.000Z",
      "updatedAt": "2024-01-62T00:00:00.000Z"
    },
    {
      "id": "63",
      "title": "63. Binary Tree Maximum Path Sum (DFS + DP pattern)",
      "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. Find the maximum path sum.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "binary-tree",
        "dynamic-programming"
      ],
      "solution": "Use DFS. For each node, calculate maximum path sum that includes that node.",
      "examples": [
        "Input: root = [1,2,3]\nOutput: 6"
      ],
      "codeSnippet": "function maxPathSum(root: TreeNode | null): number {\n  let maxSum = -Infinity;\n  function dfs(node: TreeNode | null): number {\n    if (!node) return 0;\n    const left = Math.max(0, dfs(node.left));\n    const right = Math.max(0, dfs(node.right));\n    maxSum = Math.max(maxSum, node.val + left + right);\n    return node.val + Math.max(left, right);\n  }\n  dfs(root);\n  return maxSum;\n}",
      "createdAt": "2024-01-63T00:00:00.000Z",
      "updatedAt": "2024-01-63T00:00:00.000Z"
    },
    {
      "id": "64",
      "title": "64. Binary Tree Level Order Traversal (BFS pattern)",
      "description": "Given the root of a binary tree, return the level order traversal of its nodes values.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "binary-tree",
        "bfs"
      ],
      "solution": "Use BFS with queue to process level by level.",
      "examples": [
        "Input: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]"
      ],
      "codeSnippet": "function levelOrder(root: TreeNode | null): number[][] {\n  if (!root) return [];\n  const result: number[][] = [];\n  const queue: TreeNode[] = [root];\n  while (queue.length > 0) {\n    const level: number[] = [];\n    const size = queue.length;\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift()!;\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(level);\n  }\n  return result;\n}",
      "createdAt": "2024-01-64T00:00:00.000Z",
      "updatedAt": "2024-01-64T00:00:00.000Z"
    },
    {
      "id": "65",
      "title": "65. Serialize and Deserialize Binary Tree (DFS pattern)",
      "description": "Design an algorithm to serialize and deserialize a binary tree.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "binary-tree",
        "design"
      ],
      "solution": "Use preorder traversal for serialization. Parse string recursively for deserialization.",
      "examples": [
        "Input: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]"
      ],
      "codeSnippet": "function serialize(root: TreeNode | null): string {\n  const result: string[] = [];\n  function dfs(node: TreeNode | null) {\n    if (!node) { result.push(\"null\"); return; }\n    result.push(String(node.val));\n    dfs(node.left);\n    dfs(node.right);\n  }\n  dfs(root);\n  return result.join(\",\");\n}\nfunction deserialize(data: string): TreeNode | null {\n  const values = data.split(\",\");\n  let index = 0;\n  function dfs(): TreeNode | null {\n    if (values[index] === \"null\") { index++; return null; }\n    const node = new TreeNode(parseInt(values[index++]));\n    node.left = dfs();\n    node.right = dfs();\n    return node;\n  }\n  return dfs();\n}",
      "createdAt": "2024-01-65T00:00:00.000Z",
      "updatedAt": "2024-01-65T00:00:00.000Z"
    },
    {
      "id": "66",
      "title": "66. Subtree of Another Tree (DFS pattern)",
      "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "For each node, check if subtree starting there matches subRoot.",
      "examples": [
        "Input: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true"
      ],
      "codeSnippet": "function isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {\n  if (!subRoot) return true;\n  if (!root) return false;\n  return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
      "createdAt": "2024-01-66T00:00:00.000Z",
      "updatedAt": "2024-01-66T00:00:00.000Z"
    },
    {
      "id": "67",
      "title": "67. Construct Binary Tree from Preorder and Inorder (DFS pattern)",
      "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "binary-tree",
        "array",
        "dfs"
      ],
      "solution": "Use recursion. First element of preorder is root. Find root in inorder to split left and right subtrees.",
      "examples": [
        "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]"
      ],
      "codeSnippet": "function buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n  if (preorder.length === 0) return null;\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n  const rootIndex = inorder.indexOf(rootVal);\n  root.left = buildTree(preorder.slice(1, rootIndex + 1), inorder.slice(0, rootIndex));\n  root.right = buildTree(preorder.slice(rootIndex + 1), inorder.slice(rootIndex + 1));\n  return root;\n}",
      "createdAt": "2024-01-67T00:00:00.000Z",
      "updatedAt": "2024-01-67T00:00:00.000Z"
    },
    {
      "id": "68",
      "title": "68. Validate Binary Search Tree (DFS pattern)",
      "description": "Given the root of a binary tree, determine if it is a valid binary search tree.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Use DFS with min and max bounds. For each node, check if value is within valid range.",
      "examples": [
        "Input: root = [2,1,3]\nOutput: true"
      ],
      "codeSnippet": "function isValidBST(root: TreeNode | null): boolean {\n  function validate(node: TreeNode | null, min: number, max: number): boolean {\n    if (!node) return true;\n    if (node.val <= min || node.val >= max) return false;\n    return validate(node.left, min, node.val) && validate(node.right, node.val, max);\n  }\n  return validate(root, -Infinity, Infinity);\n}",
      "createdAt": "2024-01-68T00:00:00.000Z",
      "updatedAt": "2024-01-68T00:00:00.000Z"
    },
    {
      "id": "69",
      "title": "69. Kth Smallest Element in BST (Inorder Traversal pattern)",
      "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Use inorder traversal (gives sorted order) and count nodes.",
      "examples": [
        "Input: root = [3,1,4,null,2], k = 1\nOutput: 1"
      ],
      "codeSnippet": "function kthSmallest(root: TreeNode | null, k: number): number {\n  const stack: TreeNode[] = [];\n  let current = root;\n  while (true) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop()!;\n    if (--k === 0) return current.val;\n    current = current.right;\n  }\n}",
      "createdAt": "2024-01-69T00:00:00.000Z",
      "updatedAt": "2024-01-69T00:00:00.000Z"
    },
    {
      "id": "70",
      "title": "70. Lowest Common Ancestor of BST (DFS pattern)",
      "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.",
      "category": "data-structures",
      "difficulty": "easy",
      "tags": [
        "binary-tree",
        "dfs"
      ],
      "solution": "Use BST property. If both values are smaller, go left. If both larger, go right. Otherwise, current node is LCA.",
      "examples": [
        "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6"
      ],
      "codeSnippet": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n  if (!root || root === p || root === q) return root;\n  const left = lowestCommonAncestor(root.left, p, q);\n  const right = lowestCommonAncestor(root.right, p, q);\n  if (left && right) return root;\n  return left || right;\n}",
      "createdAt": "2024-01-70T00:00:00.000Z",
      "updatedAt": "2024-01-70T00:00:00.000Z"
    },
    {
      "id": "71",
      "title": "71. Implement Trie (Trie pattern)",
      "description": "A trie (pronounced as try) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. Implement the Trie class.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "trie",
        "design"
      ],
      "solution": "Use a TrieNode class with children map and isEnd flag.",
      "examples": [
        "Input: [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\nOutput: [null, null, false, true, false, null, true]"
      ],
      "codeSnippet": "class TrieNode { children: Map<string, TrieNode>; isEnd: boolean; constructor() { this.children = new Map(); this.isEnd = false; } }\nclass Trie { root: TrieNode; constructor() { this.root = new TrieNode(); } insert(word: string): void { let node = this.root; for (let char of word) { if (!node.children.has(char)) node.children.set(char, new TrieNode()); node = node.children.get(char)!; } node.isEnd = true; } search(word: string): boolean { let node = this.root; for (let char of word) { if (!node.children.has(char)) return false; node = node.children.get(char)!; } return node.isEnd; } startsWith(prefix: string): boolean { let node = this.root; for (let char of prefix) { if (!node.children.has(char)) return false; node = node.children.get(char)!; } return true; } }",
      "createdAt": "2024-01-71T00:00:00.000Z",
      "updatedAt": "2024-01-71T00:00:00.000Z"
    },
    {
      "id": "72",
      "title": "72. Design Add and Search Words (Trie pattern)",
      "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "trie",
        "design"
      ],
      "solution": "Use Trie with special handling for . character using DFS.",
      "examples": [
        "Input: [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\nOutput: [null,null,null,null,false,true,true,true]"
      ],
      "codeSnippet": "class WordDictionary { root: TrieNode; constructor() { this.root = new TrieNode(); } addWord(word: string): void { let node = this.root; for (let char of word) { if (!node.children.has(char)) node.children.set(char, new TrieNode()); node = node.children.get(char)!; } node.isEnd = true; } search(word: string): boolean { function dfs(node: TrieNode, index: number): boolean { if (index === word.length) return node.isEnd; const char = word[index]; if (char === \".\") { for (let child of node.children.values()) { if (dfs(child, index + 1)) return true; } return false; } else { if (!node.children.has(char)) return false; return dfs(node.children.get(char)!, index + 1); } } return dfs(this.root, 0); } }",
      "createdAt": "2024-01-72T00:00:00.000Z",
      "updatedAt": "2024-01-72T00:00:00.000Z"
    },
    {
      "id": "73",
      "title": "73. Word Search II (Trie + Backtracking pattern)",
      "description": "Given an m x n board of characters and a list of strings words, return all words on the board.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "trie",
        "backtracking"
      ],
      "solution": "Build Trie from words. Use DFS on board to find words, backtracking to avoid revisiting.",
      "examples": [
        "Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]"
      ],
      "codeSnippet": "function findWords(board: string[][], words: string[]): string[] { class TrieNode { children: Map<string, TrieNode>; word: string | null; constructor() { this.children = new Map(); this.word = null; } } const root = new TrieNode(); for (let word of words) { let node = root; for (let char of word) { if (!node.children.has(char)) node.children.set(char, new TrieNode()); node = node.children.get(char)!; } node.word = word; } const result: string[] = []; function dfs(r: number, c: number, node: TrieNode) { const char = board[r][c]; const currNode = node.children.get(char)!; if (currNode.word) { result.push(currNode.word); currNode.word = null; } board[r][c] = \"#\"; for (let [dr, dc] of [[0,1],[0,-1],[1,0],[-1,0]]) { const nr = r + dr, nc = c + dc; if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length && currNode.children.has(board[nr][nc])) dfs(nr, nc, currNode); } board[r][c] = char; } for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (root.children.has(board[i][j])) dfs(i, j, root); } } return result; }",
      "createdAt": "2024-01-73T00:00:00.000Z",
      "updatedAt": "2024-01-73T00:00:00.000Z"
    },
    {
      "id": "74",
      "title": "74. Kth Largest Element in Array (Heap pattern)",
      "description": "Given an integer array nums and an integer k, return the kth largest element in the array.",
      "category": "data-structures",
      "difficulty": "medium",
      "tags": [
        "array",
        "heap"
      ],
      "solution": "Use min heap of size k, or use quickselect algorithm.",
      "examples": [
        "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5"
      ],
      "codeSnippet": "function findKthLargest(nums: number[], k: number): number { const heap: number[] = []; function addToHeap(num: number) { heap.push(num); let i = heap.length - 1; while (i > 0 && heap[Math.floor((i-1)/2)] > heap[i]) { [heap[i], heap[Math.floor((i-1)/2)]] = [heap[Math.floor((i-1)/2)], heap[i]]; i = Math.floor((i-1)/2); } } function removeMin(): number { const min = heap[0]; heap[0] = heap[heap.length - 1]; heap.pop(); let i = 0; while (true) { let smallest = i; if (2*i+1 < heap.length && heap[2*i+1] < heap[smallest]) smallest = 2*i+1; if (2*i+2 < heap.length && heap[2*i+2] < heap[smallest]) smallest = 2*i+2; if (smallest === i) break; [heap[i], heap[smallest]] = [heap[smallest], heap[i]]; i = smallest; } return min; } for (let num of nums) { addToHeap(num); if (heap.length > k) removeMin(); } return heap[0]; }",
      "createdAt": "2024-01-74T00:00:00.000Z",
      "updatedAt": "2024-01-74T00:00:00.000Z"
    },
    {
      "id": "75",
      "title": "75. Find Median from Data Stream (Heap pattern)",
      "description": "The median is the middle value in an ordered integer list. Design a data structure that supports the following two operations: addNum and findMedian.",
      "category": "data-structures",
      "difficulty": "hard",
      "tags": [
        "heap",
        "design"
      ],
      "solution": "Use two heaps: max heap for lower half, min heap for upper half. Maintain balance.",
      "examples": [
        "Input: [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\nOutput: [null, null, null, 1.5, null, 2.0]"
      ],
      "codeSnippet": "class MedianFinder { maxHeap: number[]; minHeap: number[]; constructor() { this.maxHeap = []; this.minHeap = []; } addNum(num: number): void { if (this.maxHeap.length === 0 || num <= -this.maxHeap[0]) { this.maxHeap.push(-num); this.maxHeap.sort((a, b) => b - a); } else { this.minHeap.push(num); this.minHeap.sort((a, b) => a - b); } if (this.maxHeap.length > this.minHeap.length + 1) { this.minHeap.push(-this.maxHeap.shift()!); this.minHeap.sort((a, b) => a - b); } else if (this.minHeap.length > this.maxHeap.length) { this.maxHeap.push(-this.minHeap.shift()!); this.maxHeap.sort((a, b) => b - a); } } findMedian(): number { if (this.maxHeap.length === this.minHeap.length) { return (-this.maxHeap[0] + this.minHeap[0]) / 2; } return -this.maxHeap[0]; } }",
      "createdAt": "2024-01-75T00:00:00.000Z",
      "updatedAt": "2024-01-75T00:00:00.000Z"
    },
    {
      "id": "76",
      "title": "76. Design a Parking Lot System (OOP Design pattern)",
      "description": "Design a parking lot system that can handle multiple types of vehicles and parking spots with different sizes.",
      "category": "low-level-design",
      "difficulty": "medium",
      "tags": [
        "oop",
        "system-design",
        "parking-lot"
      ],
      "solution": "Create classes for Vehicle, ParkingSpot, and ParkingLot. Use enums for vehicle types and spot sizes. Implement methods for parking, unparking, and finding available spots.",
      "examples": [
        "Park a car in a compact spot",
        "Park a truck in a large spot",
        "Find available spots for a motorcycle"
      ],
      "codeSnippet": "enum VehicleType { CAR, MOTORCYCLE, TRUCK }\nenum SpotSize { SMALL, COMPACT, LARGE }\nclass Vehicle { constructor(public type: VehicleType) {} }\nclass ParkingSpot { constructor(public id: number, public size: SpotSize, public isOccupied: boolean = false) {} }\nclass ParkingLot { private spots: ParkingSpot[] = []; park(vehicle: Vehicle): boolean { const spot = this.findAvailableSpot(vehicle.type); if (spot) { spot.isOccupied = true; return true; } return false; } private findAvailableSpot(type: VehicleType): ParkingSpot | null { return null; } }",
      "createdAt": "2024-01-04T00:00:00.000Z",
      "updatedAt": "2024-01-04T00:00:00.000Z"
    },
    {
      "id": "77",
      "title": "77. Design a LRU Cache (Hashmap + Doubly Linked List pattern)",
      "description": "Design and implement a data structure for a Least Recently Used (LRU) cache with O(1) time complexity for get and put operations.",
      "category": "low-level-design",
      "difficulty": "hard",
      "tags": [
        "cache",
        "doubly-linked-list",
        "hash-table"
      ],
      "solution": "Use a combination of HashMap and Doubly Linked List. HashMap provides O(1) access, and Doubly Linked List maintains the order of usage.",
      "examples": [
        "LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); lRUCache.put(2, 2); lRUCache.get(1); // returns 1"
      ],
      "codeSnippet": "class LRUCache { capacity: number; cache: Map<number, number>; constructor(capacity: number) { this.capacity = capacity; this.cache = new Map(); } get(key: number): number { if (!this.cache.has(key)) return -1; const value = this.cache.get(key)!; this.cache.delete(key); this.cache.set(key, value); return value; } put(key: number, value: number): void { if (this.cache.has(key)) { this.cache.delete(key); } else if (this.cache.size >= this.capacity) { const firstKey = this.cache.keys().next().value; this.cache.delete(firstKey); } this.cache.set(key, value); } }",
      "createdAt": "2024-01-05T00:00:00.000Z",
      "updatedAt": "2024-01-05T00:00:00.000Z"
    },
    {
      "id": "78",
      "title": "78. Design a Logger System (Hashmap pattern)",
      "description": "Design a logger system that receives stream of messages along with their timestamps. Each message should be printed if and only if it is not printed in the last 10 seconds.",
      "category": "low-level-design",
      "difficulty": "easy",
      "tags": [
        "logger",
        "hash-table"
      ],
      "solution": "Use a HashMap to store the last printed timestamp for each message. Check if the current timestamp is at least 10 seconds after the last printed timestamp.",
      "examples": [
        "Logger logger = new Logger(); logger.shouldPrintMessage(1, \"foo\"); // returns true"
      ],
      "codeSnippet": "class Logger { messages: Map<string, number>; constructor() { this.messages = new Map(); } shouldPrintMessage(timestamp: number, message: string): boolean { if (!this.messages.has(message) || timestamp - this.messages.get(message)! >= 10) { this.messages.set(message, timestamp); return true; } return false; } }",
      "createdAt": "2024-01-06T00:00:00.000Z",
      "updatedAt": "2024-01-06T00:00:00.000Z"
    },
    {
      "id": "79",
      "title": "79. Design a URL Shortener (TinyURL) (System Design pattern)",
      "description": "Design a service like TinyURL, a URL shortening service where you enter a URL and it returns a short URL such as tinyurl.com/4e9iAk.",
      "category": "high-level-design",
      "difficulty": "medium",
      "tags": [
        "distributed-systems",
        "scalability",
        "database"
      ],
      "solution": "Use base62 encoding for short URLs. Store mappings in a database. Use load balancers, caching (Redis), and CDN for scalability. Consider rate limiting and analytics.",
      "examples": [
        "Input: https://www.example.com/very/long/url\nOutput: https://tinyurl.com/abc123"
      ],
      "codeSnippet": "class Codec { private urlMap = new Map<string, string>(); private baseUrl = \"http://tinyurl.com/\"; private chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; encode(longUrl: string): string { let code = \"\"; while (!this.urlMap.has(code) && code.length < 6) { code = \"\"; for (let i = 0; i < 6; i++) { code += this.chars[Math.floor(Math.random() * this.chars.length)]; } } this.urlMap.set(code, longUrl); return this.baseUrl + code; } decode(shortUrl: string): string { const code = shortUrl.replace(this.baseUrl, \"\"); return this.urlMap.get(code) || \"\"; } }",
      "createdAt": "2024-01-07T00:00:00.000Z",
      "updatedAt": "2024-01-07T00:00:00.000Z"
    },
    {
      "id": "80",
      "title": "80. Design a Distributed Cache System (System Design pattern)",
      "description": "Design a distributed caching system that can handle millions of requests per second with high availability and consistency.",
      "category": "high-level-design",
      "difficulty": "hard",
      "tags": [
        "distributed-systems",
        "caching",
        "consistency"
      ],
      "solution": "Use consistent hashing for sharding. Implement replication with leader-follower pattern. Use cache eviction policies (LRU). Add monitoring and auto-scaling.",
      "examples": [
        "Handle cache misses gracefully",
        "Maintain consistency across replicas",
        "Scale horizontally"
      ],
      "codeSnippet": "// Distributed Cache System Design\n// Key components:\n// 1. Consistent Hashing for sharding\n// 2. Replication with leader-follower pattern\n// 3. Cache eviction policies (LRU)\n// 4. Load balancing\n\nclass DistributedCacheNode { id: string; data: Map<string, any>; replicas: DistributedCacheNode[]; constructor(id: string) { this.id = id; this.data = new Map(); this.replicas = []; } get(key: string): any { return this.data.get(key); } set(key: string, value: any): void { this.data.set(key, value); this.replicate(key, value); } replicate(key: string, value: any): void { for (let replica of this.replicas) { replica.data.set(key, value); } } }",
      "createdAt": "2024-01-08T00:00:00.000Z",
      "updatedAt": "2024-01-08T00:00:00.000Z"
    },
    {
      "id": "81",
      "title": "81. Design a Chat Application (System Design pattern)",
      "description": "Design a real-time chat application like WhatsApp or Slack that supports one-on-one and group messaging.",
      "category": "high-level-design",
      "difficulty": "hard",
      "tags": [
        "real-time",
        "messaging",
        "websockets"
      ],
      "solution": "Use WebSockets for real-time communication. Store messages in a database. Use message queues for reliability. Implement read receipts, typing indicators, and message delivery status.",
      "examples": [
        "Send messages in real-time",
        "Support group chats with multiple participants",
        "Handle offline message delivery"
      ],
      "codeSnippet": "// Chat Application Design\n// Key components:\n// 1. WebSocket server for real-time communication\n// 2. Message storage in database\n// 3. User presence tracking\n// 4. Message queues for reliability\n\nclass ChatMessage { id: string; senderId: string; receiverId: string; content: string; timestamp: Date; constructor(senderId: string, receiverId: string, content: string) { this.id = Math.random().toString(36); this.senderId = senderId; this.receiverId = receiverId; this.content = content; this.timestamp = new Date(); } }\n\nclass ChatService { private messages: ChatMessage[] = []; private connections = new Map<string, WebSocket>(); sendMessage(senderId: string, receiverId: string, content: string): void { const message = new ChatMessage(senderId, receiverId, content); this.messages.push(message); const receiverSocket = this.connections.get(receiverId); if (receiverSocket) { receiverSocket.send(JSON.stringify(message)); } } addConnection(userId: string, socket: WebSocket): void { this.connections.set(userId, socket); } }",
      "createdAt": "2024-01-09T00:00:00.000Z",
      "updatedAt": "2024-01-09T00:00:00.000Z"
    }
  ]
}